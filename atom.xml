<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>To conscience</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-28T09:14:46.532Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>toconscience</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础笔记（二）反射和代理</title>
    <link href="http://yoursite.com/2018/01/28/java-reflection/"/>
    <id>http://yoursite.com/2018/01/28/java-reflection/</id>
    <published>2018-01-28T00:27:10.000Z</published>
    <updated>2018-01-28T09:14:46.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础笔记（二）反射和代理"><a href="#Java基础笔记（二）反射和代理" class="headerlink" title="Java基础笔记（二）反射和代理"></a>Java基础笔记（二）反射和代理</h1><p>在阅读框架源码的时候免不了要接触反射。于是干脆把这一部分基础知识整理出来吧。</p><p>Java的反射库位于几个包下。最显著的当然是<code>java.lang.reflect</code>包。但我们先从<code>Class</code>类讲起。</p><h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><p>Java虚拟机为程序中的所有对象都维护了它们的类型信息。而从Java API的角度，有专门的类来访问这些信息，它就是<code>java.lang.Class</code>类。</p><p>要获得一个<code>Class</code>对象，大概有两种方法。</p><ol><li>使用任一对象的<code>Object.getClass()</code>方法获得一个<code>Class</code>实例。</li><li>使用静态方法<code>Class.forName()</code>，传入一个类名字符串。阅读Java文档可以发现它有几个重载方法，这里不再深入。</li></ol><blockquote><p>注意：<code>Class.forName()</code>会导致参数对应的类被初始化。至于什么是初始化——它是虚拟机的类加载机制的其中（最后）一个过程，主要的工作就是执行所有类变量的赋值动作和静态语句块。</p></blockquote><p><code>Class</code>类的另一个重要的方法是<code>newInstance()</code>，它可以创建该类的一个实例。缺点是它只会调用目标类的默认构造器（无参）。组合起来：<code>Object m = Class.forName(&quot;java.util.Random&quot;).newInstance();</code></p><p>剩下的方法主要就是一些获取类型信息的get方法。列举一部分感受一下：</p><table><thead><tr><th>Class类的方法</th></tr></thead><tbody><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getAnnotations--" target="_blank" rel="noopener">getAnnotations</a>()</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getCanonicalName--" target="_blank" rel="noopener">getCanonicalName</a>()</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getClassLoader--" target="_blank" rel="noopener">getClassLoader</a>()</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getConstructors--" target="_blank" rel="noopener">getConstructors</a>()</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getFields--" target="_blank" rel="noopener">getFields</a>()</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#isInstance-java.lang.Object-" target="_blank" rel="noopener">isInstance</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> obj)</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#isInterface--" target="_blank" rel="noopener">isInterface</a>()</td></tr></tbody></table><h3 id="用反射分析类"><a href="#用反射分析类" class="headerlink" title="用反射分析类"></a>用反射分析类</h3><p>上表讲到的<code>Class</code>类中的方法可以返回一个类型方方面面的信息。而这些方法的返回值有很多就落在了<code>java.lang.reflect</code>包中。如<code>Constructor</code>、<code>Field</code>、<code>Method</code>、<code>Modifier</code>等等，都可以顾名思义。这些类也都比较简单，提供了一些get方法来进一步获得具体信息。比如<code>Modifier</code>就有<code>isAbstract()</code>、<code>isPublic()</code>等方法。</p><p>有了反射不光可以对类型信息了如指掌，甚至可以覆盖这些信息。下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">   String r = cl.getName();</span><br><span class="line">   <span class="comment">// inspect the fields of this class and all superclasses</span></span><br><span class="line">   <span class="keyword">do</span></span><br><span class="line">   &#123;</span><br><span class="line">      r += <span class="string">"["</span>;</span><br><span class="line">      Field[] fields = cl.getDeclaredFields();</span><br><span class="line">      AccessibleObject.setAccessible(fields, <span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// get the names and values of all fields</span></span><br><span class="line">      <span class="keyword">for</span> (Field f : fields)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (!Modifier.isStatic(f.getModifiers()))</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span> (!r.endsWith(<span class="string">"["</span>)) r += <span class="string">","</span>;</span><br><span class="line">            r += f.getName() + <span class="string">"="</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">               Class t = f.getType();</span><br><span class="line">               Object val = f.get(obj);</span><br><span class="line">               <span class="keyword">if</span> (t.isPrimitive()) r += val;</span><br><span class="line">               <span class="keyword">else</span> r += toString(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      r += <span class="string">"]"</span>;</span><br><span class="line">      cl = cl.getSuperclass();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (cl != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码实现了一个简单的打印对象的方法。注意里面用到了<code>AccessibleObject.setAccessible()</code>，可以把private方法也变成可以访问。然后，调用<code>Field.get()</code>就能得到域的值。</p><h3 id="调用任意方法"><a href="#调用任意方法" class="headerlink" title="调用任意方法"></a>调用任意方法</h3><p>C和C++都有函数指针，而C#则使用委托(Delegate)来提供类似功能。Java没有函数指针或委托，它使用反射中的<code>Method</code>类来提供调用任意方法的能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method sqrt = Math.class.getMethod(&quot;sqrt&quot;, double.class);</span><br><span class="line">double y = (Double) f.invoke(null, 100);</span><br></pre></td></tr></table></figure><p>上面的代码使用反射的方式调用<code>Math</code>类的开根号函数。关于<code>Method.invoke()</code>函数的签名有两点需要注意：</p><ol><li>第一个参数用于调用的对象，当方法是static时传null。</li><li>方法的返回是一个<code>Object</code>对象，这里要显式转换成<code>Double</code>类型，然后再隐式转换成<code>double</code>基本类型。</li></ol><p>可见有了反射简直可以为所欲为，就是这么任性！</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>Java在<code>java.lang.reflect</code>包中提供<code>InvocationHandler</code>接口和<code>Proxy</code>类来帮助实现动态代理。至于什么是动态代理，可以参考这篇<a href="https://www.zhihu.com/question/20794107" target="_blank" rel="noopener">知乎问答</a>。</p><ul><li>首先，静态代理应该是普遍了解的概念了。它是OOP的一种设计模式，依赖于接口。</li><li>动态代理则是为了解决目标类方法越来越多时，代理类也要跟着膨胀的问题。因为动态代理类只要在<code>invoke()</code>方法中有选择地实现接口的方法。这对那些普遍适用的功能来说特别适合，比如缓存、认证、log等等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object tar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定委托对象，并返回代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object tar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tar = tar;</span><br><span class="line">        <span class="comment">//绑定该类实现的所有接口，取得代理类 </span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(tar.getClass().getClassLoader(),</span><br><span class="line">                                      tar.getClass().getInterfaces(),</span><br><span class="line">                                      <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke中的逻辑可以对接口中的所有方法生效。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy , Method method , Object[] args)</span><span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//在调用具体函数方法前，执行功能处理</span></span><br><span class="line">        result = method.invoke(tar,args);</span><br><span class="line">        <span class="comment">//在调用具体函数方法后，执行功能处理</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，动态代理的功能十分强大，因此得到了广泛的应用。比如Spring的AOP，单元测试中的mock框架，MyBatis的sql注解等等。</p><p>最后，动态代理仍是需要接口的。而借助另一个第三方类库CGLib，则可以动态生成字节码，不依赖于接口。Spring AOP对这两种技术都有使用。参见<a href="http://blog.csdn.net/heyutao007/article/details/49738887" target="_blank" rel="noopener">CSDN</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java基础笔记（二）反射和代理&quot;&gt;&lt;a href=&quot;#Java基础笔记（二）反射和代理&quot; class=&quot;headerlink&quot; title=&quot;Java基础笔记（二）反射和代理&quot;&gt;&lt;/a&gt;Java基础笔记（二）反射和代理&lt;/h1&gt;&lt;p&gt;在阅读框架源码的时候免不了要
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java反射" scheme="http://yoursite.com/tags/Java%E5%8F%8D%E5%B0%84/"/>
    
      <category term="代理" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础笔记（一）内部类和lambda表达式</title>
    <link href="http://yoursite.com/2018/01/24/java-lambda-and-closure/"/>
    <id>http://yoursite.com/2018/01/24/java-lambda-and-closure/</id>
    <published>2018-01-24T07:27:10.000Z</published>
    <updated>2018-01-28T09:47:05.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础笔记（一）内部类和lambda表达式"><a href="#Java基础笔记（一）内部类和lambda表达式" class="headerlink" title="Java基础笔记（一）内部类和lambda表达式"></a>Java基础笔记（一）内部类和lambda表达式</h1><h3 id="Java对函数式编程的支持"><a href="#Java对函数式编程的支持" class="headerlink" title="Java对函数式编程的支持"></a>Java对函数式编程的支持</h3><p>这里不讨论函数式编程的历史和好坏，只是要介绍Java的接口、内部类以及lambda表达式。接口不必多说，主要讲一下内部类和lambda表达式。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>函数式编程、闭包、匿名函数、lambda表达式，几乎所有的高级语言都有不同程度的支持。为了避免概念过多造成的混淆，还是有必要搞清楚闭包等重要概念。</p><p>以下三篇知乎的回答对闭包的相关知识总结的非常好：</p><ul><li><a href="https://www.zhihu.com/question/24084277/answer/110176733" target="_blank" rel="noopener">闭包（计算机科学）是什么?</a></li><li><a href="https://www.zhihu.com/question/21395848/answer/110829597" target="_blank" rel="noopener">java为什么匿名内部类的参数引用时final?</a></li><li><a href="https://www.zhihu.com/question/27416568/answer/36565794" target="_blank" rel="noopener">JVM的规范中允许编程语言语义中创建闭包(closure)吗?</a></li></ul><p><strong>简述闭包</strong>：</p><ol><li>一个依赖于自由变量的函数；</li><li>处在含有这些自由变量的一个外围环境；</li><li>这个函数能够访问外围环境里的自由变量 。</li></ol><p><strong>重点</strong>：Java对闭包只有值捕获（捕获就是指保存自由变量的动作），即值拷贝。因此就要求捕获的值不能被改变，因为改变了也无法同步。这就是为何匿名函数的自由变量在外层要被加上final修饰符了。</p><p>而C#等语言则实现了引用拷贝，在匿名函数中的自由变量和外层的变量实际上是同一引用，因而在执行时是可以改变的。具体看看<a href="https://blogs.msdn.microsoft.com/ericlippert/2009/06/18/use-your-legs-not-your-back/" target="_blank" rel="noopener">这篇文章</a>就懂了。以下引用上面回答中的一段话，言简意赅，一针见血。</p><blockquote><p>Java编译器实现的只是capture-by-value，并没有实现capture-by-reference。而只有后者才能保持匿名内部类和外部环境局部变量保持同步。但<strong>Java又不肯明说</strong>，只能粗暴地一刀切，就说既然内外不能同步，那就不许大家改外围的局部变量。</p></blockquote><p>正是太多的不好意思说，不愿明说，浪费了多少人的时间！</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> interval;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> beep;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TalkingClock</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.interval = interval;</span><br><span class="line">      <span class="keyword">this</span>.beep = beep;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Starts the clock.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      ActionListener listener = <span class="keyword">new</span> TimePrinter();</span><br><span class="line">      Timer t = <span class="keyword">new</span> Timer(interval, listener);</span><br><span class="line">      t.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The inner class.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">   </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">         <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类就是嵌套在类中的类，这没什么好说的，重点是它的方法中可以使用外层类的成员变量<code>beep</code>，并且<code>beep</code>还是私有的。</p><p>查看内部类的class文件，大致可以得到这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span>$<span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TalkingClock <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> TalkingClock$TimePrinter(TalkingClock var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">if</span> (TalkingClock.access$<span class="number">0</span>(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>)) &#123;</span><br><span class="line">            Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结原理：</p><ol><li>内部类并没有什么特殊的，编译后它便和外层类是分开的两个class文件。</li><li>内部类提供了带有一个参数的构造函数，外部类在调用<code>new TimePrinter()</code>时，会被编译器修改为传<code>this</code>参数进去，从而将外层类的引用保存在内部类的<code>this$0</code>成员变量中。</li><li>外部类的<code>beep</code>是一个自由变量，需要被<strong>捕获</strong>。编译器会为外层类的<code>beep</code>域生成一个public包装器，这里叫<code>access$0()</code>。内部类通过这个公开方法，传入外层类的引用访问外层类的私有成员。<code>access$0()</code>不是一个合法的Java方法名，因而别人不能直接访问这个方法，具有一定的安全性。然而完全可以通过生成字节码的方式访问它。</li></ol><p>因为内部类和外部类共享了同一变量的引用，所以两边都可以正常修改。如果在内部类中修改外部变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// The inner class.</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">      <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">      beep = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则会被编译为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;   ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent var1)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">if</span> (TalkingClock.access$<span class="number">100</span>(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>)) &#123;</span><br><span class="line">            Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">        TalkingClock.access$<span class="number">102</span>(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现又多了个<code>TalkingClock.access$102()</code>方法，用于设置<code>beep</code>。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>普通内部类的是放在一个类的代码块中，而局部内部类则位于一个方法块中。在访问外部类的成员变量方面，并没有什么不同。但根据闭包的原则，此局部内部类应该也能访问方法中的变量，包括方法参数和方法内的局部变量。来看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">      <span class="comment">// 局部内部类，只能是private的。</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">      </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">            <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ActionListener listener = <span class="keyword">new</span> TimePrinter();</span><br><span class="line">      Timer t = <span class="keyword">new</span> Timer(interval, listener);</span><br><span class="line">      t.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>start()</code>方法带有两个参数，而在内部类中可以访问到它们。另外还使用了一个方法的局部变量。</p><blockquote><p>坑爹的事情来了，我们来看看内部类被编译成了什么。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span>$1<span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TalkingClock <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val$numer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> val$beep;</span><br><span class="line">  </span><br><span class="line">    TalkingClock$<span class="number">1</span>TimePrinter(TalkingClock var1, <span class="keyword">int</span> var2, <span class="keyword">boolean</span> var3) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">        <span class="keyword">this</span>.val$number = var2;</span><br><span class="line">        <span class="keyword">this</span>.val$beep = var3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent var1)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.val$number);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.val$beep) &#123;</span><br><span class="line">            Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类同样被自动添加了一个构造器，并且接受一个外部类的this指针，这都跟前面一样。然而对于<code>number</code>和<code>beep</code>这两个自由变量，内部类直接存放了它们的一份<strong>值拷贝</strong>。</p><p>因为是值拷贝，在方法中或内部类中修改<code>number</code>和<code>beep</code>，并不会互相影响。所以Java设计者干脆规定这种情况下外部的自由变量必须加上final注释，以保证这些值是“事实不变的”（在Java 8后不需显式指定final，编译器会隐式添加，因此效果是一样的）。</p><p>在Scala和C#等语言中，这种情况下自由变量会被捕获为<strong>引用拷贝</strong>。例如，在C#中，自由变量会被提升(hoist)为一个类，外部类和内部类都通过类的方法访问变量。</p><p>关于Java这样做的原因，有些书籍解释说是为了线程安全——纯属扯淡！变量都不能变了，还有什么用？我更相信这个<a href="http://cuipengfei.me/blog/2013/06/22/why-does-it-have-to-be-final/" target="_blank" rel="noopener">猜测</a>：他们偷懒了。至于Java设计者为何不明说他们只实现了值拷贝，可能是为以后实现引用拷贝留条后路。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类与局部内部类的原理一模一样。只是把定义class的代码都省了，代码更短。在lambda表达式之前，这是Java传递回调的主流方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      ActionListener listener = <span class="keyword">new</span> ActionListener()</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">          </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">             <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      Timer t = <span class="keyword">new</span> Timer(interval, listener);</span><br><span class="line">      t.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>ActionListener</code>是一个接口，编译器将会创建一个实现此接口的局部内部类（名字不重要，所以匿名）。</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>作为函数式编程的核心，lambda表达式在其他很多语言中早就有了。后来终于在Java 8中被加入。在Java中的用法基本和C#相同，除了<code>=&gt;</code>换成<code>-&gt;</code>。</p><p>Java中没有像C#的委托这种东西，那么我创建一个lambda表达式，它是一个什么类型？实际上它只能转换为一个接口，准确的说是函数式接口。</p><p>只有一个抽象方法的接口叫做<strong>函数式接口</strong>。例如如下的<code>Timer</code>类接受一个<code>ActionListener</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, event -&gt; System.out.println(<span class="string">"The time is "</span> + <span class="keyword">new</span> Date()));</span><br></pre></td></tr></table></figure><p>也可以写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActionListener listener = event -&gt; System.out.println(<span class="string">"The time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, listener);</span><br></pre></td></tr></table></figure><p>同C#中有泛型的<code>Action</code>类家族和<code>Func</code>类家族来方便定义委托类似，Java也提供了泛型类来方便定义函数式接口。下表列举了一些：</p><table><thead><tr><th style="text-align:left">函数式接口</th><th style="text-align:center">参数类型</th><th style="text-align:center">返回类型</th><th style="text-align:center">抽象方法名</th></tr></thead><tbody><tr><td style="text-align:left">Runnable</td><td style="text-align:center">无</td><td style="text-align:center">void</td><td style="text-align:center">run</td></tr><tr><td style="text-align:left">Supplier<t></t></td><td style="text-align:center">无</td><td style="text-align:center">T</td><td style="text-align:center">get</td></tr><tr><td style="text-align:left">Consumer<t></t></td><td style="text-align:center">T</td><td style="text-align:center">void</td><td style="text-align:center">accept</td></tr><tr><td style="text-align:left">BiConsumer<t, u=""></t,></td><td style="text-align:center">T, U</td><td style="text-align:center">void</td><td style="text-align:center">accept</td></tr><tr><td style="text-align:left">Function<t, r=""></t,></td><td style="text-align:center">T</td><td style="text-align:center">R</td><td style="text-align:center">apply</td></tr><tr><td style="text-align:left">BiFunction<t, u,="" r=""></t,></td><td style="text-align:center">T, U</td><td style="text-align:center">R</td><td style="text-align:center">apply</td></tr><tr><td style="text-align:left">Predicate<t></t></td><td style="text-align:center">T</td><td style="text-align:center">boolean</td><td style="text-align:center">test</td></tr></tbody></table><h4 id="lambda表达式的闭包实现"><a href="#lambda表达式的闭包实现" class="headerlink" title="lambda表达式的闭包实现"></a>lambda表达式的闭包实现</h4><p>lambda表达式的自由变量捕获仍然是<strong>值捕获</strong>。因此Java同样只允许外围的自由变量是final。而要想实现内外传值怎么办呢？可以用一个称为“手动装箱”的workaround：使用长度为1的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] a = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// lambda表达式使用外部变量a, 虽然a是final, 但数组内容可变。</span></span><br><span class="line">... ( () -&gt; a[<span class="number">0</span>] = <span class="string">"a"</span> );</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当给一个接受函数式接口的方法传入一个lambda表达式时，在底层该方法仍是接受了一个实现了该接口的某个类的对象，也就是说，很类似一个匿名内部类。lambda表达式的内容将出现在类的接口方法体内。因此，Java的lambda表达式是一个跟匿名内部类很相像的东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java基础笔记（一）内部类和lambda表达式&quot;&gt;&lt;a href=&quot;#Java基础笔记（一）内部类和lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Java基础笔记（一）内部类和lambda表达式&quot;&gt;&lt;/a&gt;Java基础笔记（一）内部类
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="lambda表达式" scheme="http://yoursite.com/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>开篇</title>
    <link href="http://yoursite.com/2018/01/17/my-first-post/"/>
    <id>http://yoursite.com/2018/01/17/my-first-post/</id>
    <published>2018-01-17T13:27:10.000Z</published>
    <updated>2018-01-24T09:15:37.731Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的第一篇发布在独立站点的博客。网站名字 “To conscience” 是《至良知》的意思，相信很多人都知道我说的是王阳明。对比年少时只会把歌名作为QQ空间或者博客名，这个名字就有逼格多了，哈哈！</p><p>之所以要搭建自己的博客，是因为：公共的博客平台不乏优秀的产品，但总归有太多限制。文章水平太低怕影响自己声誉，与技术无关的又不敢放上去。有自己的博客，则不用管那么多，只需照顾自己的喜欢。</p><p>而博客又不同于日记。它能起到分享的目的；自然也失去记录隐私的功能。对于技术型的笔记，博客最好，因为一篇好的研究结论，只有自己知道太可惜，必须拿出来给大家看，才能实现其最大的价值。教是最好的学，能够用通顺的语言和合理的逻辑讲述技术，才算学到家。</p><p>对于非技术类的文章，我认为仍有分享的必要。社会哲理类的知识和思考，传播总是有好处的；人生感悟之类，也没准能找到共鸣。</p><p>写博客于我个人而言，则有以下一些好处。</p><ul><li>磨练文笔。不难察觉本篇文章的生涩。而想写好文章，必然要多写。</li><li>排解忧愁烦闷。我是一个焦虑的人，把我的焦虑讲出来，对内心是一种安慰。</li><li>提高影响力。如我将在之后的文章中频繁提到的<a href="http://tengj.top" target="_blank" rel="noopener">嘟嘟博客</a>，建立一年多，已经非常成功。</li></ul><p>这个博客站点的搭建过程也是完全依照嘟嘟的<a href="http://tengj.top/categories/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97/" target="_blank" rel="noopener">教程</a>，也许后面我会写些文章来总结有差异的地方。</p><p>希望您阅读愉快！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是我的第一篇发布在独立站点的博客。网站名字 “To conscience” 是《至良知》的意思，相信很多人都知道我说的是王阳明。对比年少时只会把歌名作为QQ空间或者博客名，这个名字就有逼格多了，哈哈！&lt;/p&gt;
&lt;p&gt;之所以要搭建自己的博客，是因为：公共的博客平台不乏优秀的
      
    
    </summary>
    
      <category term="杂文" scheme="http://yoursite.com/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="建站" scheme="http://yoursite.com/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
</feed>
